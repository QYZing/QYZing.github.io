<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/earth.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/earth.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.dying.asia","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="想都是问题，做才是答案">
<meta property="og:type" content="website">
<meta property="og:title" content="dying Blog">
<meta property="og:url" content="https://www.dying.asia/index.html">
<meta property="og:site_name" content="dying Blog">
<meta property="og:description" content="想都是问题，做才是答案">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dying">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.dying.asia/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>dying Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dying Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/08/06/ucore%20%20Lab8%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/ucore%20%20Lab8%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">ucore lab8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-06 15:45:00 / 修改时间：15:45:31" itemprop="dateCreated datePublished" datetime="2023-08-06T15:45:00+08:00">2023-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2023/08/06/ucore%20%20Lab8%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-meta-item leancloud_visitors" data-flag-title="ucore lab8" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/06/ucore%20%20Lab8%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/ucore%20%20Lab8%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ucore-Lab8-文件系统"><a href="#ucore-Lab8-文件系统" class="headerlink" title="ucore  Lab8 文件系统"></a>ucore  Lab8 文件系统</h1><h4 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h4><p>本实验依赖实验1/2/3/4/5/6/7。请把你做的实验1/2/3/4/5/6/7的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6” /“LAB7”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab8的测试应用程序，可能需对已完成的实验1/2/3/4/5/6/7的代码进行进一步改进。</p>
<p>不太需要改写什么</p>
<h4 id="练习1-完成读文件操作的实现（需要编码）"><a href="#练习1-完成读文件操作的实现（需要编码）" class="headerlink" title="练习1: 完成读文件操作的实现（需要编码）"></a>练习1: 完成读文件操作的实现（需要编码）</h4><p>文件打开大致流程</p>
<blockquote>
<ol>
<li>用户态应用程序：<ul>
<li>用户态的应用程序通过系统调用（例如 <code>open</code> 系统调用）来请求内核打开文件。</li>
</ul>
</li>
<li>系统调用接口层：<ul>
<li>在系统调用接口层，例如 <code>sys_open</code> 函数，内核获取用户态应用程序传递的参数，例如文件路径名（<code>path</code>）和打开标志（<code>open_flags</code>）。</li>
</ul>
</li>
<li>虚拟文件系统层（VFS）：<ul>
<li>在 VFS 层，内核根据传递的文件路径名找到对应的文件系统（例如 SFS 文件系统）。</li>
<li>VFS 层会调用具体文件系统的打开函数（例如 <code>sfs_open</code>）来进行文件的打开操作。</li>
</ul>
</li>
<li>文件系统层（例如 SFS 文件系统）：<ul>
<li>在文件系统层，打开函数（例如 <code>sfs_open</code>）会获取文件路径名对应的 inode，并创建 <code>struct file</code> 结构体，用于表示打开的文件。该结构体包含了与文件相关的信息，如文件的 inode、文件读写位置等。</li>
<li>打开函数还可能进行权限检查，确保应用程序有权访问该文件。</li>
</ul>
</li>
<li>返回文件描述符：<ul>
<li>在 VFS 层，打开文件后会为该文件创建一个文件描述符，并返回给用户态应用程序。文件描述符是一个整数，用于标识文件的打开状态。</li>
</ul>
</li>
<li>应用程序的文件操作：<ul>
<li>用户态应用程序在获取到文件描述符后，可以使用该文件描述符进行文件读写等操作，通过系统调用（例如 <code>read</code>、<code>write</code>）来请求内核进行相应的操作。</li>
</ul>
</li>
</ol>
</blockquote>
<p>下面给出读操作有关sfs_io_nolock函数的调用关系</p>
<blockquote>
<ol>
<li>用户程序调用 <code>sys_read</code> 系统调用：<ul>
<li>用户程序通过 <code>sys_read</code> 系统调用来请求读取文件内容。</li>
</ul>
</li>
<li>系统调用处理：<ul>
<li>内核根据系统调用号，将控制权转交给系统调用处理函数 <code>sys_read</code>。</li>
</ul>
</li>
<li>文件描述符解析：<ul>
<li><code>sys_read</code> 函数解析文件描述符，并找到对应的 <code>struct file</code> 结构体。</li>
</ul>
</li>
<li>文件读取调用：<ul>
<li><code>sys_read</code> 函数调用文件读取函数 <code>file_read</code>。</li>
<li><code>file_read</code> 函数首先检查文件读取权限，并调用文件系统抽象层函数 <code>vfs_read</code>。</li>
</ul>
</li>
<li>虚拟文件系统抽象层（VFS）：<ul>
<li><code>vfs_read</code> 函数根据文件描述符，调用 VFS 层的文件读取函数 <code>vop_read</code>。</li>
<li><code>vop_read</code> 函数根据文件节点（<code>struct vnode</code>）类型，调用不同文件系统的文件读取函数，如 <code>sfs_read</code>（用于 SFS 文件系统）。</li>
</ul>
</li>
<li>SFS 文件系统读取：<ul>
<li><code>sfs_read</code> 函数根据文件节点中的文件读写偏移量（文件指针），找到相应的磁盘块，并调用 <code>sfs_io_nolock</code> 函数读取磁盘块的数据。</li>
</ul>
</li>
<li><code>sfs_io_nolock</code>：<ul>
<li><code>sfs_io_nolock</code> 函数负责实际的读取磁盘块操作。</li>
<li>它调用 <code>sfs_read_block</code> 函数从磁盘中读取指定的数据块。</li>
</ul>
</li>
<li>磁盘读取：<ul>
<li><code>sfs_read_block</code> 函数利用设备驱动层的接口函数，将磁盘块数据从硬盘读取到内存缓冲区。</li>
</ul>
</li>
<li>数据传递：<ul>
<li><code>sfs_read_block</code> 函数将读取的数据传递给上层的 <code>sfs_read</code> 函数。</li>
</ul>
</li>
<li>数据传递至文件读取函数：<ul>
<li><code>sfs_read</code> 函数将读取的数据传递给 <code>vop_read</code> 函数。</li>
</ul>
</li>
<li>数据传递至系统调用函数：<ul>
<li><code>vop_read</code> 函数将读取的数据传递给 <code>vfs_read</code> 函数。</li>
</ul>
</li>
<li>数据传递至系统调用处理函数：<ul>
<li><code>vfs_read</code> 函数将读取的数据传递给 <code>sys_read</code> 函数。</li>
</ul>
</li>
<li>返回用户空间：<ul>
<li><code>sys_read</code> 函数将读取的数据传递回用户程序空间，并返回读取的字节数。</li>
</ul>
</li>
</ol>
</blockquote>
<p>sfs_io_nolock 实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_io_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">void</span> *buf, <span class="type">off_t</span> offset, <span class="type">size_t</span> *alenp, <span class="type">bool</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> aligned =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aligned = <span class="number">1</span>;</span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;   buf += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>)   <span class="keyword">goto</span> out;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nblks - aligned &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno + aligned, &amp;ino)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf,  ino, nblks - aligned)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += (nblks - aligned) * SFS_BLKSIZE;</span><br><span class="line">        alen += (nblks - aligned) * SFS_BLKSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno + nblks, &amp;ino)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>首先获取文件的 <code>struct sfs_disk_inode</code> 结构体指针 <code>din</code>，并对文件进行合法性检查，如文件类型不为目录等。</li>
<li>计算文件读写的结束位置 <code>endpos</code>，并进行参数合法性检查，确保读写操作在有效的范围内。</li>
<li>根据读写类型（<code>write</code>），选择对应的缓冲区操作函数 <code>sfs_buf_op</code> 和块操作函数 <code>sfs_block_op</code>，分别对应于读操作和写操作。</li>
<li>接下来，根据文件读写的开始位置 <code>offset</code> 和结束位置 <code>endpos</code>，按块为单位进行读写操作。</li>
<li>首先，处理未对齐的部分，即当前块的偏移不为0的情况。如果当前偏移不为0，则先读写当前块剩余的数据。</li>
<li>然后，处理对齐的整块数据，根据起始块号和需要读写的块数，调用相应的函数读写整块数据。</li>
<li>最后，处理结束位置不为块末尾的情况，即剩余部分不足一块的数据，再次调用相应函数读写剩余的数据。</li>
<li>在整个过程中，根据读写的大小，更新已读写数据的长度 <code>alen</code>。</li>
<li>如果读写操作结束后，文件大小发生变化，则更新文件大小，并标记文件节点为脏（<code>dirty</code>）。</li>
<li>最后，返回读写操作的结果。如果操作成功，返回0，否则返回错误码。</li>
</ol>
<h4 id="练习2-完成基于文件系统的执行程序机制的实现（需要编码）"><a href="#练习2-完成基于文件系统的执行程序机制的实现（需要编码）" class="headerlink" title="练习2: 完成基于文件系统的执行程序机制的实现（需要编码）"></a>练习2: 完成基于文件系统的执行程序机制的实现（需要编码）</h4><p>这个写起来真的好多好难啊，代码还是不放了，答案也有（鄙人不会，只能抄答案），下面给出一些该函数实现流程吧</p>
<blockquote>
<ol>
<li>首先，检查当前进程的 <code>mm</code> 是否为空。<code>mm</code> 是进程的内存管理结构，用于管理进程的虚拟地址空间。如果当前进程的 <code>mm</code> 不为空，说明内存管理结构已经被占用，这意味着当前进程已经运行了其他程序或者已经加载了其他程序，因此抛出 panic，表示异常情况。</li>
<li>创建新的 <code>mm</code> 结构，用于存放当前进程的虚拟地址空间。首先，调用 <code>mm_create()</code> 函数创建一个新的 <code>mm</code> 结构，并将返回的指针存储在 <code>mm</code> 变量中。</li>
<li>为新的 <code>mm</code> 结构设置页目录表（PDT），通过 <code>setup_pgdir()</code> 函数进行页表项的设置。该函数的目的是为了为用户程序提供一个独立的虚拟地址空间，并将用户程序的代码、数据和栈等内容映射到不同的物理页上。</li>
<li>解析 ELF 可执行文件头部，读取 ELF 文件的信息，并进行合法性检查。首先，定义一个 <code>elf</code> 结构体和一个指向该结构体的指针 <code>elfp</code>，用于存储 ELF 文件的头部信息。然后，通过 <code>load_icode_read()</code> 函数从磁盘上读取 ELF 可执行文件的头部信息到 <code>elfp</code> 中。接着，检查 ELF 文件的魔数是否正确，如果不正确则说明该 ELF 文件不合法，抛出 <code>-E_INVAL_ELF</code> 错误。</li>
<li>遍历 ELF 可执行文件的 program header 表，对 TEXT/DATA/BSS 段进行处理。首先，定义一个 <code>ph</code> 结构体和一个指向该结构体的指针 <code>php</code>，用于存储 program header 表项的信息。然后，通过循环遍历 ELF 文件的每一个 program header 表项。</li>
<li>对 TEXT/DATA 段进行分配虚拟地址空间和读取操作。对于每一个 program header 表项，首先检查其类型是否为 <code>ELF_PT_LOAD</code>，表示该段是可加载的段。然后，检查 <code>p_filesz</code> 是否大于 <code>p_memsz</code>，如果是则说明 ELF 文件不合法，抛出 <code>-E_INVAL_ELF</code> 错误。接着，判断 <code>p_filesz</code> 是否为 0，如果为 0 则说明该段没有数据需要读取，直接跳过。如果以上条件都不满足，说明该段需要加载到用户空间。</li>
<li>为 TEXT/DATA 段在用户空间分配虚拟地址空间，并将对应的数据从 ELF 文件中读取到用户空间。首先，根据 program header 表项中的虚拟地址 <code>p_va</code> 和大小 <code>p_memsz</code> 以及权限信息 <code>p_flags</code>，调用 <code>mm_map()</code> 函数将该段映射到用户空间的合适位置。接着，计算出每一页的偏移和大小，并逐页分配物理内存，并将数据从 ELF 文件中读取到相应的物理页中。</li>
<li>对 BSS 段进行分配虚拟地址空间和清零操作。对于每一个 program header 表项，同样检查其类型是否为 <code>ELF_PT_LOAD</code>，表示该段是可加载的段。然后，判断 <code>p_memsz</code> 是否大于 <code>p_filesz</code>，如果大于，则说明 BSS 段需要进行清零初始化。接着，为 BSS 段在用户空间分配虚拟地址空间，并将对应的内存空间清零。</li>
<li>为用户栈设置虚拟地址空间，并将命令行参数和用户栈的布局写入用户空间。首先，定义一些变量来辅助设置用户栈。然后，根据命令行参数计算出所需的栈空间大小，并调用 <code>mm_map()</code> 函数将用户栈映射到用户空间的合适位置。接着，根据命令行参数的长度和个数，将参数写入用户栈中。</li>
<li>切换当前进程的页目录表到新创建的用户页目录表，完成从内核空间到用户空间的切换。首先，增加新创建的 <code>mm</code> 结构的引用计数，然后将当前进程的 <code>mm</code> 指针指向新创建的 <code>mm</code> 结构，将当前进程的 CR3 寄存器设置为新的页目录表的物理地址，最后通过 <code>lcr3</code> 指令切换到用户态的页目录表。</li>
<li>最后，设置用户程序的执行环境。首先，设置中断帧 <code>tf</code>，包括代码段和数据段选择子、栈指针 <code>esp</code>、用户程序的入口地址 <code>eip</code>，以及标志寄存器 <code>eflags</code>。然后，返回 0，表示加载用户程序成功。</li>
</ol>
<p>如果在加载过程中发生错误，会进行相应的清理工作，并返回相应的错误码。这样，<code>load_icode</code> 函数负责将 ELF 可执行文件加载到用户空间中，设置用户程序执行的环境，并切换到用户态，使用户程序开始执行。</p>
</blockquote>
<p>顺便解释一下主要elf格式信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ELF头部（ELF Header）：位于文件的开头，用于描述整个ELF文件的结构和属性。包含了与ELF文件有关的一些基本信息，如文件的类型（可执行文件、共享库或目标文件）、目标硬件平台、入口点地址等。</span><br><span class="line"></span><br><span class="line">程序头表（Program Header Table）：位于ELF头部指定的偏移位置，用于描述可执行程序或共享库中各个程序段（Program Segment）的属性和位置。每个程序段描述了一个逻辑上连续的内存区域，包含了一段代码或数据。程序头表在目标文件中可以不存在，但在可执行文件和共享库中通常存在。</span><br><span class="line"></span><br><span class="line">节头表（Section Header Table）：位于ELF头部指定的偏移位置，用于描述目标文件中各个节（Section）的属性和位置。节是ELF文件的组成单位，包含了一些编译器产生的信息，如代码、数据、符号表等。</span><br><span class="line"></span><br><span class="line">符号表（Symbol Table）：位于一个特定的节中，用于描述目标文件中定义和引用的符号（变量、函数等）的信息。符号表提供了在程序中查找和链接符号的功能。</span><br><span class="line"></span><br><span class="line">字符串表（String Table）：位于一个特定的节中，用于存储目标文件中使用的字符串，如符号表中的符号名称、节的名称等。通过字符串表，可以根据字符串的偏移值找到相应的字符串。</span><br><span class="line"></span><br><span class="line">代码段和数据段：ELF文件中的代码段（Code Segment）和数据段（Data Segment）存储了程序的指令和数据。在可执行文件中，代码段包含了程序的机器指令，数据段包含了程序使用的全局变量和常量等数据。</span><br><span class="line"></span><br><span class="line">BSS段：位于数据段之后，用于存储未初始化的全局变量和静态变量。BSS段在ELF文件中并不占据实际的存储空间，而是在程序加载到内存时由系统初始化为零</span><br></pre></td></tr></table></figure>

<p>唔，至此，本人对操作系统的方方面面有了大致的框架，也了解到许多底层知识，中断描述符呀，虚拟内存，同步互斥等等，对自己提升真的好多。ucore结束了，但是操作系统还没结束</p>
<p>说实话，本人水平有限，对于ucore很多地方确实还是不太理解，没有很好掌握操作系统的内部机理，只是大致有了一个整体框架，框架内部的细节还是没有填满，最近由于处理事情较多，过段时间写CSAPP的时候，再接再厉，希望到时候我的基础会扎实一些</p>
<p><strong>祝贺你通过自己的努力，完成了ucore OS lab1-lab8!</strong></p>
<p>这段话还是恭喜你们吧，哈哈</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/08/06/ucore%20Lab5%20%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/ucore%20Lab5%20%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">ucore lab5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-06 15:45:00 / 修改时间：15:45:13" itemprop="dateCreated datePublished" datetime="2023-08-06T15:45:00+08:00">2023-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2023/08/06/ucore%20Lab5%20%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="ucore lab5" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/06/ucore%20Lab5%20%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/ucore%20Lab5%20%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ucore-Lab5-用户进程管理"><a href="#ucore-Lab5-用户进程管理" class="headerlink" title="ucore Lab5 用户进程管理"></a>ucore Lab5 用户进程管理</h1><h4 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h4><p>本实验依赖实验1/2/3/4。请把你做的实验1/2/3/4的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验1/2/3/4的代码进行进一步改进。</p>
<h6 id="改进的alloc-proc函数"><a href="#改进的alloc-proc函数" class="headerlink" title="改进的alloc_proc函数"></a>改进的alloc_proc函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *</span><br><span class="line"><span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(proc-&gt;name));</span><br><span class="line">        <span class="comment">//以下是增加条目</span></span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;yptr = proc-&gt;optr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="idt-init-在初始化IDT的时候，设置系统调用对应的中断描述符，使其能够在用户态下被调用，并且设置为trap类型。（事实上这个部分已经在LAB1的实验中顺手被完成了）"><a href="#idt-init-在初始化IDT的时候，设置系统调用对应的中断描述符，使其能够在用户态下被调用，并且设置为trap类型。（事实上这个部分已经在LAB1的实验中顺手被完成了）" class="headerlink" title="idt_init 在初始化IDT的时候，设置系统调用对应的中断描述符，使其能够在用户态下被调用，并且设置为trap类型。（事实上这个部分已经在LAB1的实验中顺手被完成了）"></a>idt_init 在初始化IDT的时候，设置系统调用对应的中断描述符，使其能够在用户态下被调用，并且设置为trap类型。（事实上这个部分已经在LAB1的实验中顺手被完成了）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gatedesc); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【注意】除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外</span></span><br><span class="line"><span class="comment">     * ，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权限；而ucore的</span></span><br><span class="line"><span class="comment">     * 应用程序处于特权级３，需要采用｀int 0x80`指令操作（这种方式称为软中断，软件</span></span><br><span class="line"><span class="comment">     * 中断，Tra中断，在lab5会碰到）来发出系统调用请求，并要能实现从特权级３到特权</span></span><br><span class="line"><span class="comment">     * 级０的转换，所以系统调用中断(T_SYSCALL)所对应的中断门描述符中的特权级（DPL）</span></span><br><span class="line"><span class="comment">     * 需要设置为３。【lab1给出的实验说明】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    <span class="comment">// this is different than  answer</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="trap-dispatch-struct-trapframe-tf-在时钟中断的处理部分，每过TICK-NUM个中断，就将当前的进程设置为可以被重新调度的，这样使得当前的线程可以被换出，从而实现多个线程的并发执行；"><a href="#trap-dispatch-struct-trapframe-tf-在时钟中断的处理部分，每过TICK-NUM个中断，就将当前的进程设置为可以被重新调度的，这样使得当前的线程可以被换出，从而实现多个线程的并发执行；" class="headerlink" title="trap_dispatch(struct trapframe *tf)  在时钟中断的处理部分，每过TICK_NUM个中断，就将当前的进程设置为可以被重新调度的，这样使得当前的线程可以被换出，从而实现多个线程的并发执行；"></a>trap_dispatch(struct trapframe *tf)  在时钟中断的处理部分，每过TICK_NUM个中断，就将当前的进程设置为可以被重新调度的，这样使得当前的线程可以被换出，从而实现多个线程的并发执行；</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ticks++;</span><br><span class="line"><span class="keyword">if</span> (ticks % TICK_NUM == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    current-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在do-fork函数中，使用set-links函数来完成将fork的线程添加到线程链表中的过程，值得注意的是，该函数中就包括了对进程总数加1这一操作，因此需要将原先的这个操作给删除掉；"><a href="#在do-fork函数中，使用set-links函数来完成将fork的线程添加到线程链表中的过程，值得注意的是，该函数中就包括了对进程总数加1这一操作，因此需要将原先的这个操作给删除掉；" class="headerlink" title="在do_fork函数中，使用set_links函数来完成将fork的线程添加到线程链表中的过程，值得注意的是，该函数中就包括了对进程总数加1这一操作，因此需要将原先的这个操作给删除掉；"></a>在do_fork函数中，使用set_links函数来完成将fork的线程添加到线程链表中的过程，值得注意的是，该函数中就包括了对进程总数加1这一操作，因此需要将原先的这个操作给删除掉；</h6><p>下面只给出部分代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">	parent = current;<span class="comment">//设置parent</span></span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);<span class="comment">//检测是否为零</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf); <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        set_links(proc);<span class="comment">//已经对nr_process增加了</span></span><br><span class="line">        <span class="comment">// list_add(&amp;proc_list, &amp;proc-&gt;list_link); //    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">        <span class="comment">// nr_process++;</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="简要描述一下进程创建过程："><a href="#简要描述一下进程创建过程：" class="headerlink" title="简要描述一下进程创建过程："></a>简要描述一下进程创建过程：</h6><p>1  程序进入kern_init开始执行</p>
<p>2     proc_init();      在调用该函数时创建了俩个内核线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="comment">//为idleproc分配内存</span></span><br><span class="line">    <span class="title function_">if</span> <span class="params">((idleproc = alloc_proc()) == <span class="literal">NULL</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//设置idleproc内核线程信息</span></span><br><span class="line">...</span><br><span class="line">    current = idleproc; <span class="comment">//设置当前为idleproc</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">//又创建了另一个内核线程，其中(init_main 是该线程的执行流)</span></span><br><span class="line">    <span class="type">int</span> pid = kernel_thread(init_main, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3 查看 init_main 发现init线程只是创建了个子线程，然后就进入循环调度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">init_main(<span class="type">void</span> *arg)</span><br><span class="line">...</span><br><span class="line">    <span class="type">int</span> pid = kernel_thread(user_main, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        panic(<span class="string">&quot;create user_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (do_wait(<span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>4  查看user_main发现调用了KERNEL_EXECVE宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">user_main</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    KERNEL_EXECVE(<span class="built_in">exit</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    panic(<span class="string">&quot;user_main execve failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5 查看该宏最终调用kernel_execve创建进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_EXECVE(name, binary, size) (&#123;           \</span></span><br><span class="line"><span class="meta">    cprintf(<span class="string">&quot;kernel_execve: pid = %d, name = \&quot;%s\&quot;.\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">            current-&gt;pid, name);                         \</span></span><br><span class="line"><span class="meta">    kernel_execve(name, binary, (size_t)(size));         \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_EXECVE(x) (&#123;                                    \</span></span><br><span class="line"><span class="meta">    extern unsigned char _binary_obj___user_##x##_out_start[], \</span></span><br><span class="line"><span class="meta">        _binary_obj___user_##x##_out_size[];                   \</span></span><br><span class="line"><span class="meta">    __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,    \</span></span><br><span class="line"><span class="meta">                    _binary_obj___user_##x##_out_size);        \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>6 而kernel_execve执行的是系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel_execve(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">char</span> *binary, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret, len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;int %1;&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span>(ret)<span class="comment">//执行SYS_exec系统调用</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;i&quot;</span>(T_SYSCALL), <span class="string">&quot;0&quot;</span>(SYS_exec), <span class="string">&quot;d&quot;</span>(name), <span class="string">&quot;c&quot;</span>(len), <span class="string">&quot;b&quot;</span>(binary), <span class="string">&quot;D&quot;</span>(size)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>7 系统调用在syscall.c中给出，通过设置了个函数指针数组进行绑定系统调用与对应函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">uint32_t</span> arg[])</span> = &#123;</span><br><span class="line">    [SYS_exit]              sys_exit,</span><br><span class="line">    [SYS_fork]              sys_fork,</span><br><span class="line">    [SYS_wait]              sys_wait,</span><br><span class="line">    [SYS_exec]              sys_exec,</span><br><span class="line">    [SYS_yield]             sys_yield,</span><br><span class="line">    [SYS_kill]              sys_kill,</span><br><span class="line">    [SYS_getpid]            sys_getpid,</span><br><span class="line">    [SYS_putc]              sys_putc,</span><br><span class="line">    [SYS_pgdir]             sys_pgdir,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="type">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(<span class="string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="练习1-加载应用程序并执行（需要编码）"><a href="#练习1-加载应用程序并执行（需要编码）" class="headerlink" title="练习1: 加载应用程序并执行（需要编码）"></a>练习1: 加载应用程序并执行（需要编码）</h4><h6 id="load-icode"><a href="#load-icode" class="headerlink" title="load_icode"></a>load_icode</h6><p>由于最终是在用户态下运行的，所以需要将段寄存器初始化为用户态的代码段、数据段、堆栈段；</p>
<p>esp应当指向先前的步骤中创建的用户栈的栈顶；</p>
<p>eip应当指向ELF可执行文件加载到内存之后的入口处；</p>
<p>eflags中应当初始化为中断使能，注意eflags的第1位是恒为1的；</p>
<p>设置ret为0，表示正常返回；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tf-&gt;tf_cs = USER_CS;</span><br><span class="line">tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss =  USER_DS;</span><br><span class="line">tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">tf-&gt;tf_eflags = FL_IF |<span class="number">0x00000002</span>;<span class="comment">//参考AmadeusChan 不加 |0x00000002 make grade有点问题</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="练习2-父进程复制自己的内存空间给子进程（需要编码）"><a href="#练习2-父进程复制自己的内存空间给子进程（需要编码）" class="headerlink" title="练习2: 父进程复制自己的内存空间给子进程（需要编码）"></a>练习2: 父进程复制自己的内存空间给子进程（需要编码）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">copy_range</span><span class="params">(<span class="type">pde_t</span> *to, <span class="type">pde_t</span> *from, <span class="type">uintptr_t</span> start, <span class="type">uintptr_t</span> end, <span class="type">bool</span> share)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; end % PGSIZE == <span class="number">0</span>);</span><br><span class="line">    assert(USER_ACCESS(start, end));</span><br><span class="line">    <span class="comment">// copy content by page unit.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// call get_pte to find process A&#x27;s pte according to the addr start</span></span><br><span class="line">        <span class="type">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep;</span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span></span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">uint32_t</span> perm = (*ptep &amp; PTE_USER);</span><br><span class="line">            <span class="comment">// get page from ptep</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep);</span><br><span class="line">            <span class="comment">// alloc a page for process B</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">npage</span> =</span> alloc_page();</span><br><span class="line">            assert(page != <span class="literal">NULL</span>);</span><br><span class="line">            assert(npage != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * (1) find src_kvaddr: the kernel virtual address of page</span></span><br><span class="line"><span class="comment">             * (2) find dst_kvaddr: the kernel virtual address of npage</span></span><br><span class="line"><span class="comment">             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span></span><br><span class="line"><span class="comment">             * (4) build the map of phy addr of  nage with the linear addr start</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">uintptr_t</span> *dst_kvaddr = page2kva(npage);</span><br><span class="line">            <span class="type">uintptr_t</span> *src_kvaddr = page2kva(page);</span><br><span class="line">            <span class="built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);</span><br><span class="line">            ret = page_insert(to, npage, start, perm);</span><br><span class="line">            assert(ret == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy_range函数就是调用一个<code>memcpy</code>将父进程的内存直接复制给子进程即可。</p>
<h4 id="练习3-阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现（不需要编码）"><a href="#练习3-阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现（不需要编码）" class="headerlink" title="练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）"></a>练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）</h4><h6 id="请分析fork-exec-wait-exit在实现中是如何影响进程的执行状态的？"><a href="#请分析fork-exec-wait-exit在实现中是如何影响进程的执行状态的？" class="headerlink" title="请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？"></a>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</h6><pre><code>系统调用分析如上
</code></pre>
<p>运行截图<br><img src="https://img-blog.csdnimg.cn/029f795dd38344c08891ecb91bdf9096.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/08/06/ucore%20lab3%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/ucore%20lab3%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">ucore lab3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-06 15:45:00 / 修改时间：15:45:01" itemprop="dateCreated datePublished" datetime="2023-08-06T15:45:00+08:00">2023-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2023/08/06/ucore%20lab3%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="ucore lab3" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/06/ucore%20lab3%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/ucore%20lab3%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ucore-lab3-虚拟内存管理"><a href="#ucore-lab3-虚拟内存管理" class="headerlink" title="ucore lab3 虚拟内存管理"></a>ucore lab3 虚拟内存管理</h1><h6 id="首先查看有关该lab的数据结构"><a href="#首先查看有关该lab的数据结构" class="headerlink" title="首先查看有关该lab的数据结构"></a>首先查看有关该lab的数据结构</h6><p>vma: 描述了一块连续的虚拟内存空间,保证start&lt;=end，<code>list_link</code>是一个双向链表，按照从小到大的顺序把一系列用<code>vma_struct</code>表示的虚拟内存空间链接起来，并且还要求这些链起来的<code>vma_struct</code>应该是不相交的，即vma之间的地址空间无交集。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">// the set of vma using the same PDT </span></span><br><span class="line">    <span class="type">uintptr_t</span> vm_start;      <span class="comment">// start addr of vma      </span></span><br><span class="line">    <span class="type">uintptr_t</span> vm_end;        <span class="comment">// end addr of vma, not include the vm_end itself</span></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags;       <span class="comment">// flags of vma</span></span><br><span class="line">    <span class="type">list_entry_t</span> list_link;  <span class="comment">// linear list link which sorted by start addr of vma</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mm_struct：管理使用同一PDT的vma集合的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span>  </span><br><span class="line">        <span class="type">list_entry_t</span> mmap_list;  <span class="comment">//双向链表头，链接了所有属于同一页目录表的虚拟内存空间</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span>  <span class="comment">//指向当前正在使用的虚拟内存空间</span></span><br><span class="line">        <span class="type">pde_t</span> *pgdir; <span class="comment">//指向的就是 mm_struct数据结构所维护的页表</span></span><br><span class="line">        <span class="type">int</span> map_count; <span class="comment">//记录mmap_list里面链接的vma_struct的个数</span></span><br><span class="line">        <span class="type">void</span> *sm_priv; <span class="comment">//指向用来链接记录页访问情况的链表头</span></span><br><span class="line"> &#125;;  </span><br></pre></td></tr></table></figure>

<p>mmap_list是双向链表头，链接了所有属于同一页目录表的虚拟内存空间，mmap_cache是指向当前正在使用的虚拟内存空间，由于操作系统执行的“局部性”原理，当前正在用到的虚拟内存空间在接下来的操作中可能还会用到，这时就不需要查链表，而是直接使用此指针就可找到下一次要用到的虚拟内存空间。pgdir 所指向的就是 mm_struct数据结构所维护的页表。通过访问pgdir可以查找某虚拟地址对应的页表项是否存在以及页表项的属性等。map_count记录mmap_list 里面链接的 vma_struct的个数。sm_priv指向用来链接记录页访问情况的链表头，这建立了mm_struct和后续要讲到的swap_manager之间的联系。</p>
<h4 id="练习1：给未被映射的地址映射上物理页（需要编程）"><a href="#练习1：给未被映射的地址映射上物理页（需要编程）" class="headerlink" title="练习1：给未被映射的地址映射上物理页（需要编程）"></a>练习1：给未被映射的地址映射上物理页（需要编程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当启动分页机制以后，如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问的类型有错误（比如写一个只读页或用户态程序访问内核态的数据等），就会发生页访问异常。产生页访问异常的原因主要有：</span><br><span class="line"></span><br><span class="line">目标页帧不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销)；</span><br><span class="line">相应的物理页帧不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上)，这在本次实验中会出现，我们将在下面介绍换页机制实现时进一步讲解如何处理；</span><br><span class="line">不满足访问权限(此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面).</span><br><span class="line">当出现上面情况之一，那么就会产生页面page fault（#PF）异常。</span><br><span class="line">CPU会把产生异常的线性地址存储在CR2中，并且把表示页访问异常类型的值（简称页访问异常错误码，errorCode）保存在中断栈中。</span><br></pre></td></tr></table></figure>

<p>do_pgfault()函数从CR2寄存器中获取页错误异常的虚拟地址，根据error code来查找这个虚拟地址是否在某一个VMA的地址范围内，并且具有正确的权限。如果满足上述两个要求，则需要为分配一个物理页。<br>所以出现page fault后，会有一个中断状态指针tf，传到trap()中处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="comment">// dispatch based on what type of trap occurred</span></span><br><span class="line">    trap_dispatch(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>调用trap_dispatch():</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"><span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line"><span class="keyword">case</span> T_PGFLT:  <span class="comment">//page fault页访问错误</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = pgfault_handler(tf)) != <span class="number">0</span>) &#123;</span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        panic(<span class="string">&quot;handle pgfault failed. %e\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为此时应该是page fault，所以调用pgfault_handler()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pgfault_handler</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">check_mm_struct</span>;</span></span><br><span class="line">    print_pgfault(tf);</span><br><span class="line">    <span class="keyword">if</span> (check_mm_struct != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> do_pgfault(check_mm_struct, tf-&gt;tf_err, rcr2());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//CR2存储了产生异常的线性地址</span></span><br><span class="line">    panic(<span class="string">&quot;unhandled page fault.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后调用了do_pgfault()</p>
<p>给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ptep = get_pte(mm-&gt;pgdir , addr , <span class="number">1</span>);  <span class="comment">//(1) try to find a pte, if pte&#x27;s PT(Page Table) isn&#x27;t existed, then create a PT.</span></span><br><span class="line"><span class="keyword">if</span>(ptep == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;get_pte in do_pgfault failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> failed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;                      <span class="comment">//(2) if the phy addr isn&#x27;t exist, then alloc a page &amp; map the phy addr with logical addr</span></span><br><span class="line">    <span class="keyword">if</span>(pgdir_alloc_page(mm-&gt;pgdir , addr , perm) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。</p>
</li>
<li><p>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
</li>
</ul>
<h4 id="练习2：补充完成基于FIFO的页面替换算法"><a href="#练习2：补充完成基于FIFO的页面替换算法" class="headerlink" title="练习2：补充完成基于FIFO的页面替换算法"></a>练习2：补充完成基于FIFO的页面替换算法</h4><p>页替换算法接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">     <span class="comment">/* Global initialization for the swap manager */</span></span><br><span class="line">     <span class="type">int</span> (*init)            (<span class="type">void</span>);</span><br><span class="line">     <span class="comment">/* Initialize the priv data inside mm_struct */</span></span><br><span class="line">     <span class="type">int</span> (*init_mm)         (<span class="keyword">struct</span> mm_struct *mm);</span><br><span class="line">     <span class="comment">/* Called when tick interrupt occured */</span></span><br><span class="line">     <span class="type">int</span> (*tick_event)      (<span class="keyword">struct</span> mm_struct *mm);</span><br><span class="line">     <span class="comment">/* Called when map a swappable page into the mm_struct */</span></span><br><span class="line">     <span class="type">int</span> (*map_swappable)   (<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr, <span class="keyword">struct</span> Page *page, <span class="type">int</span> swap_in);</span><br><span class="line">     <span class="comment">/* When a page is marked as shared, this routine is called to</span></span><br><span class="line"><span class="comment">      * delete the addr entry from the swap manager */</span></span><br><span class="line">     <span class="type">int</span> (*set_unswappable) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr);</span><br><span class="line">     <span class="comment">/* Try to swap out a page, return then victim */</span></span><br><span class="line">     <span class="type">int</span> (*swap_out_victim) (<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> Page **ptr_page, <span class="type">int</span> in_tick);</span><br><span class="line">     <span class="comment">/* check the page relpacement algorithm */</span></span><br><span class="line">     <span class="type">int</span> (*check_swap)(<span class="type">void</span>);     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>do_pgfault()函数中的部分代码：用于执行页面从磁盘获取并设置页面可替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">           <span class="keyword">if</span>(swap_in(mm , addr , &amp;page) != <span class="number">0</span> )&#123;  <span class="comment">//根据mm和addr尝试在磁盘中加载对应的页</span></span><br><span class="line">               cprintf(<span class="string">&quot;swap_in in do_pgfault failed\n&quot;</span>); </span><br><span class="line">               <span class="keyword">goto</span> failed;</span><br><span class="line">           &#125;</span><br><span class="line">           page_insert(mm-&gt;pgdir , page ,addr , perm);     <span class="comment">//(2) 插入页并对物理地址和虚拟地址映射</span></span><br><span class="line">           swap_map_swappable(mm, addr , page , <span class="number">1</span>);       <span class="comment">//(3) 设置为可被切换</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">           <span class="keyword">goto</span> failed;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>_fifo_swap_out_vistim</code>函数主要实现页面的换出，<code>_fifo_map_swappable</code>用于添加页面并记录内容。</p>
<h6 id="fifo-map-swappable：根据规则在头部添加了一下"><a href="#fifo-map-swappable：根据规则在头部添加了一下" class="headerlink" title="_fifo_map_swappable：根据规则在头部添加了一下"></a>_fifo_map_swappable：根据规则在头部添加了一下</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_fifo_map_swappable(<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr, <span class="keyword">struct</span> Page *page, <span class="type">int</span> swap_in)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_entry_t</span> *head=(<span class="type">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    <span class="type">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"> </span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//record the page access situlation</span></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span> </span><br><span class="line">    <span class="comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span></span><br><span class="line">    list_add(head , entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="fifo-swap-out-victim：删除尾部页面"><a href="#fifo-swap-out-victim：删除尾部页面" class="headerlink" title="_fifo_swap_out_victim：删除尾部页面"></a>_fifo_swap_out_victim：删除尾部页面</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_fifo_swap_out_victim(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> Page ** ptr_page, <span class="type">int</span> in_tick)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">list_entry_t</span> *head=(<span class="type">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>);</span><br><span class="line">     <span class="comment">/* Select the victim */</span></span><br><span class="line">     <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span> </span><br><span class="line">     <span class="comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span></span><br><span class="line">     <span class="comment">//(2)  set the addr of addr of this page to ptr_page</span></span><br><span class="line">     <span class="type">list_entry_t</span> *ulink_pg = head-&gt;prev;</span><br><span class="line">     assert(head != ulink_pg);</span><br><span class="line">     list_del(ulink_pg);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> le2page(ulink_pg , pra_page_link);</span><br><span class="line">     assert(page != <span class="literal">NULL</span>);</span><br><span class="line">     *ptr_page = page;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/08/06/ucore%20lab4%20%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/ucore%20lab4%20%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">ucore lab4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-06 15:45:00 / 修改时间：15:45:07" itemprop="dateCreated datePublished" datetime="2023-08-06T15:45:00+08:00">2023-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2023/08/06/ucore%20lab4%20%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="ucore lab4" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/06/ucore%20lab4%20%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/ucore%20lab4%20%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ucore-lab4-内核线程管理"><a href="#ucore-lab4-内核线程管理" class="headerlink" title="ucore lab4 内核线程管理"></a>ucore lab4 内核线程管理</h1><h4 id="练习1：分配并初始化一个进程控制块（需要编码）"><a href="#练习1：分配并初始化一个进程控制块（需要编码）" class="headerlink" title="练习1：分配并初始化一个进程控制块（需要编码）"></a>练习1：分配并初始化一个进程控制块（需要编码）</h4><h6 id="alloc-proc"><a href="#alloc-proc" class="headerlink" title="alloc_proc"></a>alloc_proc</h6><p>分配内存 -&gt; 初始化（清空）-&gt;返回进程块地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *</span><br><span class="line"><span class="title function_">alloc_proc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc_struct));<span class="comment">//分配内存快</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	proc-&gt;state = PROC_UNINIT;<span class="comment">//设置进程初始状态</span></span><br><span class="line">    	proc-&gt;pid = <span class="number">-1</span>; <span class="comment">// 初始化id</span></span><br><span class="line">    	proc-&gt;runs = <span class="number">0</span> ;<span class="comment">//初始化时间片</span></span><br><span class="line">    	proc-&gt;kstack = <span class="number">0</span>;<span class="comment">//内核栈地址</span></span><br><span class="line">    	proc-&gt;need_resched = <span class="number">0</span>;<span class="comment">//不需要调度</span></span><br><span class="line">    	proc-&gt;parent = <span class="literal">NULL</span>;<span class="comment">//无父进程</span></span><br><span class="line">    	proc-&gt;mm = <span class="literal">NULL</span>;<span class="comment">//虚拟内存为空</span></span><br><span class="line">    	<span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> context));<span class="comment">//初始化清空上下文</span></span><br><span class="line">    	proc-&gt;tf = <span class="literal">NULL</span>;<span class="comment">//初始化中断帧指针</span></span><br><span class="line">    	proc-&gt;cr3 = boot_cr3;<span class="comment">//默认页目录为内核页目录表的基地址</span></span><br><span class="line">    	proc-&gt;flags = <span class="number">0</span>;<span class="comment">//初始化标志位</span></span><br><span class="line">    	<span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span> , <span class="keyword">sizeof</span>(proc-&gt;name));<span class="comment">//初始化名字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="请说明proc-struct中struct-context-context和struct-trapframe-tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）"><a href="#请说明proc-struct中struct-context-context和struct-trapframe-tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）" class="headerlink" title="请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）"></a>请说明proc_struct中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）</h6><p>​    context：报存的是进程运行时的上下文（各个寄存器状态），用于进程切换时，不丢失进程运行环境</p>
<p>​    tf: 中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时tf 总是能够指向当前的trapframe，uCore 在内核栈上维护了 tf 的链。</p>
<h4 id="练习2：为新创建的内核线程分配资源（需要编码）"><a href="#练习2：为新创建的内核线程分配资源（需要编码）" class="headerlink" title="练习2：为新创建的内核线程分配资源（需要编码）"></a>练习2：为新创建的内核线程分配资源（需要编码）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span>((proc = alloc_proc()) == <span class="literal">NULL</span>)&#123;<span class="comment">//    1. 创建pcb</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current; <span class="comment">// 设置父进程为current</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(setup_kstack(proc) != <span class="number">0</span> )&#123;<span class="comment">// 2. 调用setup_kstack分配内核栈</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(copy_mm(clone_flags , proc) != <span class="number">0</span> )&#123;<span class="comment">//3.调用copy_mm 复制父进程内存信息（也可能是共享）</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc , <span class="built_in">stack</span> ,tf); <span class="comment">// 4. 调用copy_thread 复制上下文和中断帧</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);<span class="comment">// 关中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();<span class="comment">//分配id</span></span><br><span class="line">        hash_proc(proc);<span class="comment">//放入hash链表</span></span><br><span class="line">        list_add(&amp;proc_list , &amp;proc-&gt;list_link); <span class="comment">//    5. 插入proc_list</span></span><br><span class="line">        nr_process++;<span class="comment">//进程数++</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);<span class="comment">//开中断</span></span><br><span class="line">   </span><br><span class="line">    wakeup_proc(proc);<span class="comment">//    6. 唤醒新进程</span></span><br><span class="line">    ret =  proc-&gt;pid;<span class="comment">//    7. 返回pid</span></span><br><span class="line"></span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">//分配失败收场工作</span></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br></pre></td></tr></table></figure>

<h6 id="请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。"><a href="#请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。" class="headerlink" title="请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。"></a>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</h6><p>会的</p>
<p>get_pid</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">get_pid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="type">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> next_safe = MAX_PID, last_pid = MAX_PID;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span> (++ last_pid &gt;= MAX_PID) &#123;<span class="comment">//超过MAX_PID 就重新计数</span></span><br><span class="line">        last_pid = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe) &#123;<span class="comment">//</span></span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>last_pid=上一次分配的pid.当分配超过MAX_PID时从1开始重新分配<br>(last_pid,next_safe)指定了一段连续的未分配的pid区间.如果last_pid &lt; next_safe时直接分配last_pid+1,否则以1为单位增加pid,每次增加都遍历整个proc_list查重,并更新next_safe,如果冲突了就再增1,从头再判断</p>
<h4 id="练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。（无编码工作）"><a href="#练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。（无编码工作）" class="headerlink" title="练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）"></a>练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）</h4><p>下面是调度函数</p>
<p>1 调度开始时，先屏蔽中断。</p>
<p>2 在进程链表中，查找第一个可以被调度的程序</p>
<p>3 运行新进程，允许中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);<span class="comment">//保存中断开关状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">            sched_class_enqueue(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((next = sched_class_pick_next()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sched_class_dequeue(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;<span class="comment">//没有就调内核线程</span></span><br><span class="line">            next = idleproc;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123;</span><br><span class="line">            proc_run(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);<span class="comment">//恢复中断开关状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">proc_run(<span class="keyword">struct</span> proc_struct *proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">        <span class="type">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag);<span class="comment">//保存中断开关状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;<span class="comment">//设置当前进程为proc</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);<span class="comment">//更新tss的特权态0下的栈顶指针esp0为新进程的栈顶</span></span><br><span class="line">            lcr3(next-&gt;cr3);<span class="comment">//更新CR3位新进程页目录表物理地址,完成进程间页表切换</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<span class="comment">//切换当前进程和新进程的上下文</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);<span class="comment">//恢复中断开关状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="在本实验的执行过程中，创建且运行了几个内核线程？"><a href="#在本实验的执行过程中，创建且运行了几个内核线程？" class="headerlink" title="在本实验的执行过程中，创建且运行了几个内核线程？"></a>在本实验的执行过程中，创建且运行了几个内核线程？</h6><p>俩个</p>
<p>idleproc： ucore： 第一个内核进程，完成内核中各个子系统的初始化，之后立即调度，执行其他进程。</p>
<p>initproc：用于完成实验的功能而调度的内核进程。</p>
<h6 id="语句local-intr-save-intr-flag-local-intr-restore-intr-flag-在这里有何作用-请说明理由"><a href="#语句local-intr-save-intr-flag-local-intr-restore-intr-flag-在这里有何作用-请说明理由" class="headerlink" title="语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由"></a>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用?请说明理由</h6><p>作用分别是屏蔽中断和打开中断，以免进程切换时其他进程再进行调度。也就是保护进程切换不会被中断，以免进程切换时其他进程再进行调度，相当于互斥锁。之前在第六步添加进程到列表的时候也需要有这个操作，是因为进程进入列表的时候，可能会发生一系列的调度事件，比如我们所熟知的抢断等，加上这么一个保护机制可以确保进程执行不被打乱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line">__intr_save(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (read_eflags() &amp; FL_IF) &#123;<span class="comment">//看看关了没，没关就关，并且如果这里关了就返回1，没关就返回0</span></span><br><span class="line">        intr_disable();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__intr_restore(<span class="type">bool</span> flag) &#123;<span class="comment">//根据上次关时候的返回值看看打不打开中断（这样中断就可以嵌套）</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        intr_enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_intr_save(x)      do &#123; x = __intr_save(); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_intr_restore(x)   __intr_restore(x);</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/08/06/ucore%20lab6%20%E8%B0%83%E5%BA%A6%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/ucore%20lab6%20%E8%B0%83%E5%BA%A6%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">ucore lab6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-06 15:45:00 / 修改时间：15:45:19" itemprop="dateCreated datePublished" datetime="2023-08-06T15:45:00+08:00">2023-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2023/08/06/ucore%20lab6%20%E8%B0%83%E5%BA%A6%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="ucore lab6" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/06/ucore%20lab6%20%E8%B0%83%E5%BA%A6%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/ucore%20lab6%20%E8%B0%83%E5%BA%A6%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ucore-lab6-调度管理机制"><a href="#ucore-lab6-调度管理机制" class="headerlink" title="ucore lab6 调度管理机制"></a>ucore lab6 调度管理机制</h1><h4 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h4><p>具体更改的地方如下：</p>
<p>proc.c 中alloc_proc新增加内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;rq = <span class="literal">NULL</span>;</span><br><span class="line">list_init(&amp;proc-&gt;run_link);</span><br><span class="line"><span class="comment">//proc-&gt;run_link.next = proc-&gt;run_link.prev = NULL ;</span></span><br><span class="line">proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = <span class="literal">NULL</span>;</span><br><span class="line">proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">proc-&gt;lab6_priority = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>链表初始化应该用list_init而不是空</p>
<p>priority要设置成1，不能设置为0，因为后续有的代码会除以这个数字，设置为0可能有bug</p>
<h4 id="练习1-使用-Round-Robin-调度算法（不需要编码）"><a href="#练习1-使用-Round-Robin-调度算法（不需要编码）" class="headerlink" title="练习1: 使用 Round Robin 调度算法（不需要编码）"></a>练习1: 使用 Round Robin 调度算法（不需要编码）</h4><p>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 算法名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">//初始化算法用数据</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="keyword">struct</span> run_queue *rq);</span><br><span class="line">    <span class="comment">// 当有进程设置为可调度时调用该函数放入就绪队列</span></span><br><span class="line">    <span class="type">void</span> (*enqueue)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line">    <span class="comment">//在就绪队列中选出一个去运行然后在就绪队列中一出该信息</span></span><br><span class="line">    <span class="type">void</span> (*dequeue)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line">    <span class="comment">//查看就绪队列中下一个是谁可以运行 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">//每次时钟中断时调用该函数，该函数需要处理，占用cpu时间片的剩余以及是否可调度</span></span><br><span class="line">    <span class="type">void</span> (*proc_tick)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ucore调度过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">         <span class="comment">//   cprintf(&quot;insert into %p\n&quot; , current);</span></span><br><span class="line">            sched_class_enqueue(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((next = sched_class_pick_next()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">//  cprintf(&quot;dequeue out %p\n&quot; , next);</span></span><br><span class="line">            sched_class_dequeue(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            next = idleproc;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123;</span><br><span class="line">         <span class="comment">//   cprintf(&quot;run %p \n&quot; , next);</span></span><br><span class="line">            proc_run(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    首先就是创建俩个内核线程，一个执行初始化后是死循环调度，另一个则是创建子进程然后调度</p>
<p>​    子线程通过do_fork 一出生就被挂到proc_list和hash_list这个链表上了，顺带调用wakeup_proc这个函数然    后就通过进程    调度算法的入队方式挂上去了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup_proc</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">            proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);<span class="comment">//这个函数就是挂到调度算法列表上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warn(<span class="string">&quot;wakeup runnable process.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来就是，要么时钟中断，要么进程自己放弃cpu然后同过调度算法切换另一个进程，而该算法逻辑是给进程分配一个时间片，然后每一个时钟中断检测一下进程的时间片，要是用完了，就通过调度算法，将进程放到就绪列表尾部。，然后等待下次调度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">RR_enqueue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));<span class="comment">//放到尾部</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中trap.c中是通过run_timer_list函数来实现每次进程时间片减少的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">run_timer_list</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="type">timer_t</span> *timer = le2timer(le, timer_link);</span><br><span class="line">            assert(timer-&gt;expires != <span class="number">0</span>);</span><br><span class="line">            timer-&gt;expires --;</span><br><span class="line">            <span class="keyword">while</span> (timer-&gt;expires == <span class="number">0</span>) &#123;</span><br><span class="line">                le = list_next(le);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> timer-&gt;proc;</span><br><span class="line">                <span class="keyword">if</span> (proc-&gt;wait_state != <span class="number">0</span>) &#123;</span><br><span class="line">                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    warn(<span class="string">&quot;process %d&#x27;s wait_state == 0.\n&quot;</span>, proc-&gt;pid);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeup_proc(proc);</span><br><span class="line">                del_timer(timer);</span><br><span class="line">                <span class="keyword">if</span> (le == &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                timer = le2timer(le, timer_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        sched_class_proc_tick(current);就走了个这个</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>嗯~~   一大堆代码，但是在lab6中好像没有用到if里的就走了  sched_class_proc_tick(current);来调用调度算法的RR_proc_tick这个</p>
<p>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计</p>
<p>嗯~ 不会</p>
<h4 id="练习2-实现-Stride-Scheduling-调度算法（需要编码）"><a href="#练习2-实现-Stride-Scheduling-调度算法（需要编码）" class="headerlink" title="练习2: 实现 Stride Scheduling 调度算法（需要编码）"></a>练习2: 实现 Stride Scheduling 调度算法（需要编码）</h4><p>首先是这个BIG_STRIDE应该取多少值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">proc_stride_comp_f</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">     <span class="type">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来仔细分析一下吧：</p>
<p>​    在具体实现时，有一个需要注意的地方：stride属性的溢出问题，在之前的实现里面我们并没有考虑 stride 的数值范围，而这个值在理论上是不断增加的，在 stride溢出以后，基于stride的比较可能会出现错误。比如假设当前存在两个进程A和B，stride属性采用16位无符号整数进行存储。当前队列中元素如下（假设当前运行的进程已经被重新放置进运行队列中）：</p>
<p><img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab6_figs/image001.png" alt="image"></p>
<p>此时应该选择 A 作为调度的进程，而在一轮调度后，队列将如下：</p>
<p><img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab6_figs/image002.png" alt="image"></p>
<p>可以看到由于溢出的出现，进程间stride的理论比较和实际比较结果出现了偏差。我们首先在理论上分析这个问题：令PASS_MAX为当前所有进程里最大的步进值。则我们可以证明如下结论：对每次Stride调度器的调度步骤中，有其最大的步进值STRIDE_MAX和最小的步进值STRIDE_MIN之差：</p>
<p>STRIDE_MAX – STRIDE_MIN &lt;= PASS_MAX</p>
<p>有了该结论，在加上之前对优先级有Priority &gt; 1限制，我们有STRIDE_MAX – STRIDE_MIN &lt;= BIG_STRIDE,于是我们只要将BigStride取在某个范围之内，即可保证对于任意两个 Stride 之差都会在机器整数表示的范围之内。而我们可以通过其与0的比较结构，来得到两个Stride的大小关系。在上例中，虽然在直接的数值表示上 98 &lt; 65535，但是 98 - 65535 的结果用带符号的 16位整数表示的结果为99,与理论值之差相等。所以在这个意义下 98 &gt; 65535。基于这种特殊考虑的比较方法，即便Stride有可能溢出，我们仍能够得到理论上的当前最小Stride，并做出正确的调度决定。</p>
<p>所以最后应该取 0x7FFFFFFF 即 (((uint32_t)-1) / 2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define BIG_STRIDE 0x7FFFFFFF /* you should give a value, and is ??? */</span><br></pre></td></tr></table></figure>

<p>然后就是</p>
<p>　stride调度算法是抢占式的。在<strong>stride_enqueue</strong>中，每当就绪队列入队时都会为其分配一定的时间片，当线程运行的过程中发生时钟中断时则会通过<strong>stride_proc_tick</strong>函数扣减对应的时间片。当为线程分配的时间片扣减为0时，则会将线程的need_resched设置为1。</p>
<p>　　在trap中断处理函数中，当对应中断号的处理例程返回时会单独的检查need_resched的值，当发现为1时，则会触发schedule函数进行一次强制的线程调度，从而令当前时间片扣减为0的线程得以让出CPU，使其它的就绪线程能得到执行的机会。<strong>这也是stride调度算法被称为抢占式调度算法的原因：无论当前执行的线程是否主动的让出cpu，在分配的时间片用完之后，操作系统将会强制的撤下当前线程，进行一次调度</strong>，通过如下就可以看出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dispatch based on what type of trap occurred</span></span><br><span class="line">    <span class="comment">// used for previous projects</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// keep a trapframe chain in stack</span></span><br><span class="line">        <span class="keyword">struct</span> trapframe *otf = current-&gt;tf;</span><br><span class="line">        current-&gt;tf = tf;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> in_kernel = trap_in_kernel(tf);</span><br><span class="line"></span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line"></span><br><span class="line">        current-&gt;tf = otf;</span><br><span class="line">        <span class="keyword">if</span> (!in_kernel)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING)</span><br><span class="line">            &#123;</span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;need_resched)</span><br><span class="line">            &#123;</span><br><span class="line">                schedule();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_init</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">     list_init(&amp;rq-&gt;run_list);</span><br><span class="line">     rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">     rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_enqueue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span></span><br><span class="line">&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;proc-&gt;lab6_run_pool, proc_stride_comp_f);</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice)</span><br><span class="line">     &#123;</span><br><span class="line">          proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">     &#125;</span><br><span class="line">     proc-&gt;rq = rq;</span><br><span class="line">     rq-&gt;proc_num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_dequeue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span></span><br><span class="line">&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool =  skew_heap_remove(rq-&gt;lab6_run_pool, &amp;proc-&gt;lab6_run_pool, proc_stride_comp_f);</span><br><span class="line">     rq-&gt;proc_num--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *</span><br><span class="line"><span class="title function_">stride_pick_next</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">     <span class="keyword">if</span>(p-&gt;lab6_priority == <span class="number">0</span>)&#123;</span><br><span class="line">          p-&gt;lab6_stride += BIG_STRIDE;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_proc_tick</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          proc-&gt;time_slice--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>)&#123;</span><br><span class="line">          proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整体理解算法不难，因为人家的斜堆已经给出了，不需要自己实现</p>
<p>　<strong>斜堆结构实现的就绪队列其入队、出队操作能达到O(logn)的对数复杂度，比其双向链表实现的就绪队列入队、出队效率O(n)要高出一个数量级</strong> </p>
<p>　</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/08/06/ucore%20lab7%20%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/ucore%20lab7%20%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" class="post-title-link" itemprop="url">ucore lab7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-06 15:45:00 / 修改时间：15:45:25" itemprop="dateCreated datePublished" datetime="2023-08-06T15:45:00+08:00">2023-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2023/08/06/ucore%20lab7%20%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" class="post-meta-item leancloud_visitors" data-flag-title="ucore lab7" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/06/ucore%20lab7%20%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/ucore%20lab7%20%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ucore-lab7-同步互斥"><a href="#ucore-lab7-同步互斥" class="headerlink" title="ucore lab7 同步互斥"></a>ucore lab7 同步互斥</h1><h4 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h4><p>对kern/trap/trap.c中的lab6 code中的sched_class_proc_tick(current)改成run_timer_list()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks ++;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        run_timer_list(); <span class="comment">//这里 </span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h4 id="练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）"><a href="#练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）" class="headerlink" title="练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）"></a>练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）</h4><h6 id="请在实验报告中给出内核级信号量的设计描述，并说明其大致执行流程。"><a href="#请在实验报告中给出内核级信号量的设计描述，并说明其大致执行流程。" class="headerlink" title="请在实验报告中给出内核级信号量的设计描述，并说明其大致执行流程。"></a>请在实验报告中给出内核级信号量的设计描述，并说明其大致执行流程。</h6><p>可以看出内核信号量结构体中就是个值，和队列而已</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait_queue;</span><br><span class="line">&#125; <span class="type">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">try_down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>首先分析  up函数（完成V操作），发现只是调用了_up把sem传入了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">up</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span> &#123;</span><br><span class="line">    __up(sem, WT_KSEM);<span class="comment">//WT_KSEM：  0x00000100  //等待内核信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后来看一下_up</p>
<p>大致手段就是禁用中断的方式来处理（在单核有效，多核无效）</p>
<p>禁用中断后，首先判断是否有等待的，没有就把值++</p>
<p>有的话直接唤醒他就行（就是简化了一下++之后在–，所以就直接唤醒就行，方便写）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __noinline <span class="type">void</span> __up(<span class="type">semaphore_t</span> *sem, <span class="type">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">wait_t</span> *wait;</span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后看一下down操作（P操作）类似调用了_down</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags = __down(sem, WT_KSEM);</span><br><span class="line">    assert(flags == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先关中断</p>
<p>然后查看value，如果有的话就–然后恢复中断了</p>
<p>没有value的话，把当前放到等待队列里，然后执行调度（让别人去占用cpu）</p>
<p>然后等别人有value了把自己叫醒</p>
<p>​        关中断，把等待链表上的自己删掉，恢复中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> __noinline <span class="type">uint32_t</span> __down(<span class="type">semaphore_t</span> *sem, <span class="type">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value&gt;0，表示共享资源的空闲数<br>vlaue&lt;0，表示该信号量的等待队列里的进程数<br>value=0，表示等待队列为空</p>
<h6 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------- philosophers problem using semaphore ----------------------</span></span><br><span class="line"><span class="type">int</span> state_sema[N]; <span class="comment">/* 记录每个人状态的数组 */</span></span><br><span class="line"><span class="comment">/* 信号量是一个特殊的整型变量 */</span></span><br><span class="line"><span class="type">semaphore_t</span> mutex; <span class="comment">/* 临界区互斥 */</span></span><br><span class="line"><span class="type">semaphore_t</span> s[N];  <span class="comment">/* 每个哲学家一个信号量 */</span></span><br></pre></td></tr></table></figure>

<p>说白了就是  先弄个互斥锁，然后看看自己能抢不，不能让别人到时候调用我的phi_test_sema去抢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phi_take_forks_sema</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;mutex);           <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    state_sema[i] = HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">    phi_test_sema(i);       <span class="comment">/* 试图得到两只叉子 */</span></span><br><span class="line">    up(&amp;mutex);             <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    down(&amp;s[i]);            <span class="comment">/* 如果得不到叉子就阻塞 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是 吃饭的人不吃了，然后看看左边的人想吃不，和右边的人想吃不</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phi_put_forks_sema</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;mutex);             <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    state_sema[i] = THINKING; <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">    phi_test_sema(LEFT);      <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">    phi_test_sema(RIGHT);     <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line">    up(&amp;mutex);               <span class="comment">/* 离开临界区 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体就是，一个信号量表示公共的互斥操作，五个信号量（也算是条件变量了）表示状态（阻塞，非阻塞）</p>
<p>自己阻塞的时候，通过别人调用下面的函数来唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phi_test_sema</span><span class="params">(i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_sema[i] == HUNGRY &amp;&amp; state_sema[LEFT] != EATING &amp;&amp; state_sema[RIGHT] != EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        state_sema[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程的操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">philosopher_using_semaphore</span><span class="params">(<span class="type">void</span> *arg)</span> <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, iter = <span class="number">0</span>;</span><br><span class="line">    i = (<span class="type">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_sema\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">while</span> (iter++ &lt; TIMES)</span><br><span class="line">    &#123;                                                                      <span class="comment">/* 无限循环 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is thinking\n&quot;</span>, iter, i); <span class="comment">/* 哲学家正在思考 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_sema(i);</span><br><span class="line">        <span class="comment">/* 需要两只叉子，或者阻塞 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is eating\n&quot;</span>, iter, i); <span class="comment">/* 进餐 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_sema(i);</span><br><span class="line">        <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_sema quit\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）"><a href="#练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）" class="headerlink" title="练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）"></a>练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）</h4><p>内核级条件变量的哲学家就餐问题在<code>check_sync</code>处实现。同信号量的测试相似，这里也是创建了5个内核进程表示5个哲学家的行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">check_sync</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//check condition variable</span></span><br><span class="line">    monitor_init(&amp;mt, N);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        state_condvar[i]=THINKING;</span><br><span class="line">        <span class="type">int</span> pid = kernel_thread(philosopher_using_condvar, (<span class="type">void</span> *)i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;create No.%d philosopher_using_condvar failed.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        philosopher_proc_condvar[i] = find_proc(pid);</span><br><span class="line">        set_proc_name(philosopher_proc_condvar[i], <span class="string">&quot;philosopher_condvar_proc&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>每个线程也是调用phi_test_condvar(i)尝试自己获取到叉子，自己获取不到，那就让别人帮自己调用phi_test_condvar这个函数来获取</p>
<p>同时在尝试获取不到叉子时候调用 cond_wait(&amp;mtp-&gt;cv[i]);阻塞自己，等待别人唤醒，因为有可能唤醒之后，自己还是没有EATING所以要用循环判断，直到自己获取到了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phi_take_forks_condvar</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line">    <span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">    <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    <span class="comment">// I am hungry</span></span><br><span class="line">    state_condvar[i] = HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">                            <span class="comment">// try to get fork</span></span><br><span class="line">    phi_test_condvar(i);</span><br><span class="line">    <span class="keyword">while</span> (state_condvar[i] != EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_take_forks_condvar: %d didn&#x27;t get fork and will wait\n&quot;</span>, i);</span><br><span class="line">        cond_wait(&amp;mtp-&gt;cv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">    <span class="keyword">if</span> (mtp-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中下面是管程的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     down(&amp;(mtp-&gt;mutex));</span><br><span class="line">    	。。。。</span><br><span class="line">    <span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">    <span class="keyword">if</span> (mtp-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。管程由以下四部分组成：<br>①管程内部的共享变量；<br>②管程内部的条件变量；<br>③管程内部并发执行的进程；<br>④对局部于管程内部的共享数据设置初始值的语句。</p>
<p>即一个管程由一个锁和多个条件变量组成。由此可见，管程相当于一个隔离区，它把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程，从而需要确保进程之间互斥。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> <span class="title">monitor_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;        <span class="comment">// the sem semaphore  is used to down the waiting proc, and the signaling proc should up the waiting proc</span></span><br><span class="line">    <span class="type">int</span> count;              <span class="comment">// the number of waiters on condvar</span></span><br><span class="line">    <span class="type">monitor_t</span> * owner;      <span class="comment">// the owner(monitor) of this condvar</span></span><br><span class="line">&#125; <span class="type">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> mutex;      <span class="comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span></span><br><span class="line">    <span class="type">semaphore_t</span> next;       <span class="comment">// the next semaphore is used to down the signaling proc itself, and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.</span></span><br><span class="line">    <span class="type">int</span> next_count;         <span class="comment">// the number of of sleeped signaling proc</span></span><br><span class="line">    <span class="type">condvar_t</span> *cv;          <span class="comment">// the condvars in monitor</span></span><br><span class="line">&#125; <span class="type">monitor_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>管程中的成员变量mutex是一个二值信号量，是实现每次只允许一个进程进入管程的关键元素，确保了互斥访问性质。管程中的条件变量cv通过执行wait_cv，会使得等待某个条件C为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行；而进入管程的某进程设置条件C为真并执行signal_cv时，能够让等待某个条件C为真的睡眠进程被唤醒，从而继续进入管程中执行。管程中的成员变量信号量next和整形变量next_count是配合进程对条件变量cv的操作而设置的，这是由于发出signal_cv的进程A会唤醒睡眠进程B，进程B执行会导致进程A睡眠，直到进程B离开管程，进程A才能继续执行，这个同步过程是通过信号量next完成的；而next_count表示了由于发出singal_cv而睡眠的进程个数。<br>然后下面就是实现管程中条件变量（信号量模拟）的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cond_signal</span><span class="params">(<span class="type">condvar_t</span> *cvp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cvp-&gt;count &gt; <span class="number">0</span>) <span class="comment">//确保有人在阻塞</span></span><br><span class="line">    &#123;</span><br><span class="line">        cvp-&gt;owner-&gt;next_count++;<span class="comment">//管程只能同时有一个线程在运行，所以要把自己挂起来</span></span><br><span class="line">        up(&amp;cvp-&gt;sem);<span class="comment">//唤醒别人</span></span><br><span class="line">        down(&amp;cvp-&gt;owner-&gt;next);<span class="comment">//阻塞自己</span></span><br><span class="line">        cvp-&gt;owner-&gt;next_count--;<span class="comment">//自己阻塞没了就--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cond_wait</span><span class="params">(<span class="type">condvar_t</span> *cvp)</span></span><br><span class="line">&#123;</span><br><span class="line">    cvp-&gt;count++;<span class="comment">//等待数++</span></span><br><span class="line">    <span class="keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>)&#123; <span class="comment">// 如果说别人是因为条件变量阻塞的</span></span><br><span class="line">        up(&amp;cvp-&gt;owner-&gt;next);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//是不是条件变量阻塞的就是互斥锁阻塞</span></span><br><span class="line">        up(&amp;cvp-&gt;owner-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    down(&amp;cvp-&gt;sem);<span class="comment">//阻塞自己</span></span><br><span class="line">    cvp-&gt;count--;<span class="comment">//接触阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是哲学家操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phi_take_forks_condvar</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line">    <span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">    <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    <span class="comment">// I am hungry</span></span><br><span class="line">    state_condvar[i] = HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span>                     </span><br><span class="line">    phi_test_condvar(i);  <span class="comment">// try to get fork</span></span><br><span class="line">    <span class="keyword">while</span> (state_condvar[i] != EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_take_forks_condvar: %d didn&#x27;t get fork and will wait\n&quot;</span>, i);</span><br><span class="line">        cond_wait(&amp;mtp-&gt;cv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">    <span class="keyword">if</span> (mtp-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">phi_put_forks_condvar</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">    <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    <span class="comment">// I ate over</span></span><br><span class="line">    state_condvar[i] = THINKING;</span><br><span class="line">    <span class="comment">// test left and right neighbors</span></span><br><span class="line">    phi_test_condvar(LEFT);</span><br><span class="line">    phi_test_condvar(RIGHT);</span><br><span class="line">    <span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">    <span class="keyword">if</span> (mtp-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是代码操作</p>
<p>总体来说，我有点菜，这节的管程还是没太理解，没办法用简单的话语描述，下去在仔细了解一下把</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/08/06/ucore%20lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/ucore%20lab1/" class="post-title-link" itemprop="url">ucore lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-06 15:44:00 / 修改时间：15:44:39" itemprop="dateCreated datePublished" datetime="2023-08-06T15:44:00+08:00">2023-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2023/08/06/ucore%20lab1/" class="post-meta-item leancloud_visitors" data-flag-title="ucore lab1" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/06/ucore%20lab1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/ucore%20lab1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ucore-lab1"><a href="#ucore-lab1" class="headerlink" title="ucore lab1"></a>ucore lab1</h1><h4 id="练习1：理解通过make生成执行文件的过程。（要求在报告中写出对下述问题的回答）"><a href="#练习1：理解通过make生成执行文件的过程。（要求在报告中写出对下述问题的回答）" class="headerlink" title="练习1：理解通过make生成执行文件的过程。（要求在报告中写出对下述问题的回答）"></a>练习1：理解通过make生成执行文件的过程。（要求在报告中写出对下述问题的回答）</h4><h5 id="1-操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果"><a href="#1-操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果" class="headerlink" title="1 .操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)"></a>1 .操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</h5><h6 id="首先查看ucore-img生成规则，发现ucore-img生成依赖于kernel和bootblock"><a href="#首先查看ucore-img生成规则，发现ucore-img生成依赖于kernel和bootblock" class="headerlink" title="首先查看ucore.img生成规则，发现ucore.img生成依赖于kernel和bootblock"></a>首先查看ucore.img生成规则，发现ucore.img生成依赖于kernel和bootblock</h6><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create ucore.img</span></span><br><span class="line">UCOREIMG	:= <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,ucore.img)</span></span><br></pre></td></tr></table></figure>

<p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。$@是输出文件名</p>
<p>第一行dd：就是开辟一块存储区域大小为10000 * 512字节然后将/dev/zero （0）输入进去【初始化一块区域】</p>
<p>第二行dd：读取bootblock（512字节）内容然后输出到$@ 转换格式为 notrunc(不截短输出文件) </p>
<p>第三行dd：读取kernel内容然后输出到$@ 转换格式同上。 注意有偏移seek=1 偏移 1 * 512 位置</p>
<p>有关dd命令可以查看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78414544">linux下的dd命令使用详解 - 知乎 (zhihu.com)</a></p>
<p>说白了就是弄一块磁盘区域来把kernel和bootblock按照头512字节是bootblock然后其次是kernel放进去，在模拟的时候这个文件要放到指定磁盘位置，然后BLOS启动时会读取磁盘上该文件的内容，bootblock作为bootloader引导代码然后加载kernel了</p>
<h6 id="其次查看kernel生成规则"><a href="#其次查看kernel生成规则" class="headerlink" title="其次查看kernel生成规则"></a>其次查看kernel生成规则</h6><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create kernel target</span></span><br><span class="line">kernel = <span class="variable">$(<span class="built_in">call</span> totarget,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: tools/kernel.ld</span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,kernel)</span></span><br></pre></td></tr></table></figure>

<p>kernel赋值为”bin/kernel”</p>
<p>执行toos/kernel.ld链接脚本</p>
<p>编译kernel\下的所有.s和.c文件</p>
<h6 id="然后看一下bootblock"><a href="#然后看一下bootblock" class="headerlink" title="然后看一下bootblock"></a>然后看一下bootblock</h6><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># create bootblock</span></span><br><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>)</span><br><span class="line"><span class="comment">#编译boot\下的所有C文件</span></span><br><span class="line"></span><br><span class="line">bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,bootblock)</span></span><br><span class="line"><span class="comment">#编译boot\下所有文件,并链接bootblock文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create &#x27;sign&#x27; tools</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span></span><br><span class="line"><span class="comment">#前面需要sign这个，这里就是编译,tools/sign.c并调用</span></span><br></pre></td></tr></table></figure>

<p>发现前面都用到了$(call totarget,…) totarget定义在tools/function.mk</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">totarget = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BINDIR)</span><span class="variable">$(SLASH)</span>,$(1)</span>)</span><br><span class="line"><span class="comment">#BINDIR在别处定义为&quot;bin&quot;,slash定义为斜线&quot;/&quot;,$(1)指代输入参数</span></span><br><span class="line"><span class="comment">#所以totarget作用为给输入参数添加前缀&quot;bin/&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h5><p>阅读sign.c可知,大小小于512字节且以0X55AA结尾</p>
<h4 id="练习3：分析bootloader进入保护模式的过程。"><a href="#练习3：分析bootloader进入保护模式的过程。" class="headerlink" title="练习3：分析bootloader进入保护模式的过程。"></a>练习3：分析bootloader进入保护模式的过程。</h4><h6 id="1-关闭中断，初始化寄存器为0"><a href="#1-关闭中断，初始化寄存器为0" class="headerlink" title="1 关闭中断，初始化寄存器为0"></a>1 关闭中断，初始化寄存器为0</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cli                                             # Disable interrupts</span><br><span class="line">cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line"># Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">movw %ax, %ss                                   # -&gt; Stack Segment</span><br></pre></td></tr></table></figure>

<h6 id="2-开启A20"><a href="#2-开启A20" class="headerlink" title="2 开启A20:"></a>2 开启A20:</h6><p>​    为了兼容早期版本初始化时物理地址只能寻址20位也就是1M，所以要开启A20这样物理寻址就能达到32位也就是4G</p>
<h6 id="3-同时载入全局描述表"><a href="#3-同时载入全局描述表" class="headerlink" title="3 同时载入全局描述表"></a>3 同时载入全局描述表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdtdesc</span><br></pre></td></tr></table></figure>

<h6 id="4-进入保护模式，将cr0寄存器PE置1，开启保护模式"><a href="#4-进入保护模式，将cr0寄存器PE置1，开启保护模式" class="headerlink" title="4 进入保护模式，将cr0寄存器PE置1，开启保护模式"></a>4 进入保护模式，将cr0寄存器PE置1，开启保护模式</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl %cr0, %eax</span><br><span class="line">orl $CR0_PE_ON, %eax</span><br><span class="line">movl %eax, %cr0</span><br></pre></td></tr></table></figure>

<h6 id="5-通过长跳转更新cs的基地址"><a href="#5-通过长跳转更新cs的基地址" class="headerlink" title="5 通过长跳转更新cs的基地址"></a>5 通过长跳转更新cs的基地址</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>

<h6 id="6-设置段寄存器，建立堆栈"><a href="#6-设置段寄存器，建立堆栈" class="headerlink" title="6 设置段寄存器，建立堆栈"></a>6 设置段寄存器，建立堆栈</h6><h6 id="7-转到保护模式完成，call进入bootmain"><a href="#7-转到保护模式完成，call进入bootmain" class="headerlink" title="7 转到保护模式完成，call进入bootmain"></a>7 转到保护模式完成，call进入bootmain</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call bootmain</span><br></pre></td></tr></table></figure>

<h4 id="练习4：分析bootloader加载ELF格式的OS的过程。"><a href="#练习4：分析bootloader加载ELF格式的OS的过程。" class="headerlink" title="练习4：分析bootloader加载ELF格式的OS的过程。"></a>练习4：分析bootloader加载ELF格式的OS的过程。</h4><p>先从磁盘开始处读取了1页(8个扇区,每个512byte)的数据到内存64K处,再校验头部标识符是否合法.<br>接着从磁盘中读取每个程序段,并放到虚拟内存对应位置.<br>最后执行ELF入口程序,将控制权交给kernel</p>
<h4 id="练习5：实现函数调用堆栈跟踪函数-（需要编程）"><a href="#练习5：实现函数调用堆栈跟踪函数-（需要编程）" class="headerlink" title="练习5：实现函数调用堆栈跟踪函数 （需要编程）"></a>练习5：实现函数调用堆栈跟踪函数 （需要编程）</h4><p>考察的是对EBP寄存器的运用.几乎所有本地编译器都会在每个函数体之前插入类似如下的汇编指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushl %ebp</span><br><span class="line">movl %esp,%ebp</span><br></pre></td></tr></table></figure>

<p>这两条汇编指令的含义是：首先将ebp寄存器入栈，然后将栈顶指针esp赋值给ebp。“mov ebp esp”这条指令表面上看是用esp覆盖ebp原来的值，其实不然。因为给ebp赋值之前，原ebp值已经被压栈（位于栈顶），而新的ebp又恰恰指向栈顶。此时ebp寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原ebp入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值。</p>
<p>一般而言，ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用4字节内存），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层ebp值。由于ebp中的地址处总是“上一层函数调用时的ebp值”，而在每一层函数调用中，都能通过当时的ebp值“向上（栈底方向）”能获取返回地址、参数值，“向下（栈顶方向）”能获取函数局部变量值。如此形成递归，直至到达栈底。这就是函数调用栈。</p>
<p>由文档给出的不难理解，双层循环内层循环复则打印，外层循环复则查看堆栈调用，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eip = ((<span class="type">uint32_t</span> *)ebp)[<span class="number">1</span>];</span><br><span class="line">ebp = ((<span class="type">uint32_t</span> *)ebp)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h4 id="练习6：完善中断初始化和处理"><a href="#练习6：完善中断初始化和处理" class="headerlink" title="练习6：完善中断初始化和处理"></a>练习6：完善中断初始化和处理</h4><h5 id="1-中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？"><a href="#1-中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？" class="headerlink" title="1 中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？"></a>1 中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Gate descriptors for interrupts and traps */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_15_0 : <span class="number">16</span>;        <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">    <span class="type">unsigned</span> gd_ss : <span class="number">16</span>;            <span class="comment">// segment selector</span></span><br><span class="line">    <span class="type">unsigned</span> gd_args : <span class="number">5</span>;            <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">    <span class="type">unsigned</span> gd_rsv1 : <span class="number">3</span>;            <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_type : <span class="number">4</span>;            <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_s : <span class="number">1</span>;                <span class="comment">// must be 0 (system)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">    <span class="type">unsigned</span> gd_p : <span class="number">1</span>;                <span class="comment">// Present</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_31_16 : <span class="number">16</span>;        <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出一个表项为8字节（64位）其中0 ~ 15位和48 ~ 63位分别为偏移量的低16位和高16位，两者拼接为偏移量，16~31位为段选择器。通过段选择子去GDT中找到对应的基地址，然后基地址加上偏移量就是中断处理程序的地址。</p>
<h5 id="2-请编程完善kern-trap-trap-c中对中断向量表进行初始化的函数idt-init。在idt-init函数中，依次对所有中断入口进行初始化。使用mmu-h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools-vectors-c生成，使用trap-c中声明的vectors数组即可"><a href="#2-请编程完善kern-trap-trap-c中对中断向量表进行初始化的函数idt-init。在idt-init函数中，依次对所有中断入口进行初始化。使用mmu-h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools-vectors-c生成，使用trap-c中声明的vectors数组即可" class="headerlink" title="2 请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可"></a>2 请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __vectors[];</span><br><span class="line"><span class="type">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gatedesc); i++ )&#123;</span><br><span class="line">    SETGATE(idt[i] , <span class="number">0</span> , GD_KTEXT , __vectors[i]  ,  DPL_KERNEL );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【注意】除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外</span></span><br><span class="line"><span class="comment"> * ，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权限；而ucore的</span></span><br><span class="line"><span class="comment"> * 应用程序处于特权级３，需要采用｀int 0x80`指令操作（这种方式称为软中断，软件</span></span><br><span class="line"><span class="comment"> * 中断，Tra中断，在lab5会碰到）来发出系统调用请求，并要能实现从特权级３到特权</span></span><br><span class="line"><span class="comment"> * 级０的转换，所以系统调用中断(T_SYSCALL)所对应的中断门描述符中的特权级（DPL）</span></span><br><span class="line"><span class="comment"> * 需要设置为３。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SETGATE(idt[T_SYSCALL] , <span class="number">1</span> , GD_KTEXT , __vectors[T_SYSCALL] , DPL_USER);</span><br><span class="line"><span class="comment">// this is different than  answer</span></span><br><span class="line">lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure>

<p>就是找一些宏去填就行了，找宏很麻烦，其他还好</p>
<h5 id="3-请编程完善trap-c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print-ticks子程序，向屏幕上打印一行文字”100-ticks”。"><a href="#3-请编程完善trap-c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print-ticks子程序，向屏幕上打印一行文字”100-ticks”。" class="headerlink" title="3 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。"></a>3 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</h5><p> Too Simple? Yes, I think so!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></span><br><span class="line">  <span class="comment">/* handle the timer interrupt */</span></span><br><span class="line">  <span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></span><br><span class="line"><span class="comment">   * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span></span><br><span class="line"><span class="comment">   * (3) Too Simple? Yes, I think so!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ticks++;</span><br><span class="line">  <span class="keyword">if</span>(ticks % TICK_NUM  == <span class="number">0</span>)&#123;</span><br><span class="line">      print_ticks();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h6 id="整体流程完成后就可以看到大约一秒会打印一个ticks，还能获取到键盘响应"><a href="#整体流程完成后就可以看到大约一秒会打印一个ticks，还能获取到键盘响应" class="headerlink" title="整体流程完成后就可以看到大约一秒会打印一个ticks，还能获取到键盘响应"></a>整体流程完成后就可以看到大约一秒会打印一个ticks，还能获取到键盘响应</h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/08/06/ucore%20lab2%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/ucore%20lab2%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">ucore lab2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-06 15:44:00 / 修改时间：15:44:55" itemprop="dateCreated datePublished" datetime="2023-08-06T15:44:00+08:00">2023-08-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span id="/2023/08/06/ucore%20lab2%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="ucore lab2" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/08/06/ucore%20lab2%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/ucore%20lab2%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ucore-lab2-物理内存管理"><a href="#ucore-lab2-物理内存管理" class="headerlink" title="ucore lab2 物理内存管理"></a>ucore lab2 物理内存管理</h1><h4 id="练习1：实现-first-fit-连续物理内存分配算法（需要编程）"><a href="#练习1：实现-first-fit-连续物理内存分配算法（需要编程）" class="headerlink" title="练习1：实现 first-fit 连续物理内存分配算法（需要编程）"></a><strong>练习1：实现 first-fit 连续物理内存分配算法（需要编程）</strong></h4><h6 id="default-init-void"><a href="#default-init-void" class="headerlink" title="default_init(void)"></a>default_init(void)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化一个链表</span><br></pre></td></tr></table></figure>

<h6 id="default-init-memmap-struct-Page-base-size-t-n"><a href="#default-init-memmap-struct-Page-base-size-t-n" class="headerlink" title="default_init_memmap(struct Page *base, size_t n)"></a>default_init_memmap(struct Page *base, size_t n)</h6><p>就是将空闲内存挂在空闲链表上，我看答案是一个一个都挂上去了，然后将开头设置包含后面的信息，而我是直接一把他们变成一整块挂在链表上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">default_init_memmap</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(PageReserved(p));</span><br><span class="line">        p-&gt;flags = PG_property;</span><br><span class="line">        p-&gt;property = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">        SetPageProperty(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    list_add_before(&amp;free_list, &amp;(base-&gt;page_link));</span><br><span class="line">    base-&gt;property = n;</span><br><span class="line"></span><br><span class="line">    nr_free += n;</span><br><span class="line">    <span class="comment">// list_add(&amp;free_list, &amp;(base-&gt;page_link));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="default-alloc-pages-size-t-n"><a href="#default-alloc-pages-size-t-n" class="headerlink" title="default_alloc_pages(size_t n)"></a>default_alloc_pages(size_t n)</h6><p>分配内存的时候，遍历空闲链表，遇到第一个可以用的就取下来，如果还比较大就切一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> Page *</span><br><span class="line"><span class="title function_">default_alloc_pages</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> $DEBUG</span></span><br><span class="line">            cprintf(<span class="string">&quot;\n!!!!!!!!!!!memory alloc :!!!!!!!!!!!!!!!!!\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list)<span class="comment">//遍历找到合适内存块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, page_link);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SetPageReserved(page);</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n)<span class="comment">//比较大时先切下来放到空闲列表上然后在删，不然找不到位置了就</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page + n;</span><br><span class="line">            p-&gt;property = page-&gt;property - n;</span><br><span class="line">            list_add(&amp;page-&gt;page_link, &amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">        list_del(&amp;(page-&gt;page_link));</span><br><span class="line">        nr_free -= n;</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG </span></span><br><span class="line">        le = &amp;free_list;</span><br><span class="line">        <span class="keyword">while</span>((le = list_next(le)) != &amp;free_list)</span><br><span class="line">        &#123;</span><br><span class="line">            page = le2page(le , page_link);</span><br><span class="line">            cprintf(<span class="string">&quot;memory page address = %p ,property  = %ld\n&quot;</span> , page , page-&gt;property);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="default-free-pages-struct-Page-base-size-t-n"><a href="#default-free-pages-struct-Page-base-size-t-n" class="headerlink" title="default_free_pages(struct Page *base, size_t n)"></a>default_free_pages(struct Page *base, size_t n)</h6><p>释放时，也是先找位置，我是直接找到该位置后面的一个位置，然后循环向前看能否合并，不能合并break就行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">   <span class="keyword">do</span>&#123;<span class="comment">//找位置</span></span><br><span class="line">       le = list_next(le);</span><br><span class="line">       <span class="meta">#<span class="keyword">ifdef</span> $DEBUG</span></span><br><span class="line">           cprintf(<span class="string">&quot;...loop location base-&gt;link = %p le = %p \n&quot;</span>, &amp;base-&gt;page_link, le);</span><br><span class="line">       <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">   &#125; <span class="keyword">while</span> (&amp;base-&gt;page_link &gt; le &amp;&amp; le != &amp;free_list);<span class="comment">// search location</span></span><br><span class="line"></span><br><span class="line">   p = le2page(le, page_link);</span><br><span class="line">   le = list_prev(le);</span><br><span class="line">   <span class="keyword">if</span> (base + base-&gt;property == p)<span class="comment">//看一下后面的能否合并</span></span><br><span class="line">   &#123;</span><br><span class="line">       base-&gt;property += p-&gt;property;</span><br><span class="line">       ClearPageProperty(p);</span><br><span class="line">       list_del(&amp;(p-&gt;page_link));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (le != &amp;free_list)<span class="comment">//看一下前面的能否合并</span></span><br><span class="line">   &#123;</span><br><span class="line">       p = le2page(le, page_link);</span><br><span class="line">       <span class="keyword">if</span> (p + p-&gt;property == base)</span><br><span class="line">       &#123;</span><br><span class="line">           p-&gt;property += base-&gt;property;</span><br><span class="line">           ClearPageProperty(base);</span><br><span class="line">           base = p;</span><br><span class="line">           list_del(&amp;(p-&gt;page_link));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       le = list_prev(le);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>总结：大致上就是链表的基本操作，不过要注意，分配释放时的标志信息要改写，感觉我的不太对在某些时候，有时候遍历输出的时候遍历链表就死循环了，但是看起来分配和回收时不影响，有些神奇</p>
<h4 id="练习2：实现寻找虚拟地址对应的页表项（需要编程）"><a href="#练习2：实现寻找虚拟地址对应的页表项（需要编程）" class="headerlink" title="练习2：实现寻找虚拟地址对应的页表项（需要编程）"></a><strong>练习2：实现寻找虚拟地址对应的页表项（需要编程）</strong></h4><h6 id="get-pte-pde-t-pgdir-uintptr-t-la-bool-create"><a href="#get-pte-pde-t-pgdir-uintptr-t-la-bool-create" class="headerlink" title="get_pte(pde_t *pgdir, uintptr_t la, bool create)"></a>get_pte(pde_t *pgdir, uintptr_t la, bool create)</h6><p>参数定义：pgdir页目录起始地址 ， la是线性地址 ，create是否创造</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get_pte - get pte and return the kernel virtual address of this pte for la</span></span><br><span class="line"><span class="comment">//         - if the PT contains this pte didn&#x27;t exist, alloc a page for PT</span></span><br><span class="line"><span class="comment">//  parameter:</span></span><br><span class="line"><span class="comment">//   pgdir:  the kernel virtual base address of PDT</span></span><br><span class="line"><span class="comment">//   la:     the linear address need to map</span></span><br><span class="line"><span class="comment">//   create: a logical value to decide if alloc a page for PT</span></span><br><span class="line"><span class="comment">//  return vaule: the kernel virtual address of this pte</span></span><br></pre></td></tr></table></figure>

<p>首先要获取页目录对应的表项配合la的偏移计算 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pde_t</span> *pdep = &amp;pgdir[PDX(la)]; <span class="comment">// (1) find page directory entry</span></span><br></pre></td></tr></table></figure>

<p>然后显看是否存在，存在就直接返回对应配合la计算出来的页表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;((<span class="type">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)]; <span class="comment">// (8) return page table entry</span></span><br></pre></td></tr></table></figure>

<p>不存在则要看需不需要创造</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(*pdep &amp; PTE_P))          <span class="comment">// (2) check if entry is not present</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!create || (page = alloc_page()) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;                <span class="comment">// (3) check if creating is needed, then alloc page for page table</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// CAUTION: this page is used for page table, not for common data page</span></span><br><span class="line">    &#125;</span><br><span class="line">    set_page_ref(page, <span class="number">1</span>);              <span class="comment">// (4) set page reference</span></span><br><span class="line">    <span class="type">uintptr_t</span> pa = page2pa(page);       <span class="comment">// (5) get linear address of page</span></span><br><span class="line">    <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);       <span class="comment">// (6) clear page content using memset</span></span><br><span class="line">    *pdep = pa | PTE_P | PTE_W | PTE_U; <span class="comment">// (7) set page directory entry&#x27;s permission</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个地址就很晕哎</p>
<h4 id="练习3：释放某虚地址所在的页并取消对应二级页表项的映射（需要编程）"><a href="#练习3：释放某虚地址所在的页并取消对应二级页表项的映射（需要编程）" class="headerlink" title="练习3：释放某虚地址所在的页并取消对应二级页表项的映射（需要编程）"></a><strong>练习3：释放某虚地址所在的页并取消对应二级页表项的映射（需要编程）</strong></h4><h6 id="page-remove-pte-pde-t-pgdir-uintptr-t-la-pte-t-ptep"><a href="#page-remove-pte-pde-t-pgdir-uintptr-t-la-pte-t-ptep" class="headerlink" title="page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep)"></a>page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (*ptep &amp; PTE_P)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep); <span class="comment">//(2) find corresponding page to pte</span></span><br><span class="line">    <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>)    <span class="comment">//(3) decrease page reference</span></span><br><span class="line">    &#123;                             </span><br><span class="line">        free_page(page); <span class="comment">//(4) and free this page when page reference reachs 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    *ptep = <span class="number">0</span>; <span class="comment">//(5) clear second page table entry</span></span><br><span class="line"></span><br><span class="line">    tlb_invalidate(pgdir, la); <span class="comment">//(6) flush tlb</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释太全了，直接写了就行</p>
<p>注：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                          Permissions</span></span><br><span class="line"><span class="comment"> *                                                              kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     4G ------------------&gt; +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |         Empty Memory (*)        |</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+ 0xFB000000</span></span><br><span class="line"><span class="comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span></span><br><span class="line"><span class="comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/06/13/Buffer%20Pool%EF%BC%88cmu15445%20project1%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/13/Buffer%20Pool%EF%BC%88cmu15445%20project1%EF%BC%89/" class="post-title-link" itemprop="url">Buffer Pool (cmu15445 project1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-13 23:22:00 / 修改时间：22:08:27" itemprop="dateCreated datePublished" datetime="2023-06-13T23:22:00+08:00">2023-06-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cs-lab/" itemprop="url" rel="index"><span itemprop="name">cs-lab</span></a>
                </span>
            </span>

          
            <span id="/2023/06/13/Buffer%20Pool%EF%BC%88cmu15445%20project1%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="Buffer Pool (cmu15445 project1)" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/06/13/Buffer%20Pool%EF%BC%88cmu15445%20project1%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/06/13/Buffer%20Pool%EF%BC%88cmu15445%20project1%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Buffer-Pool（cmu15445-project1）"><a href="#Buffer-Pool（cmu15445-project1）" class="headerlink" title="Buffer Pool（cmu15445 project1）"></a>Buffer Pool（cmu15445 project1）</h1><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>这次需要实现三个文件 可扩展哈希表，LRU-K  BufferPool</p>
<p>这个project相较于之前难度上升了许多</p>
<p>其中 Extendible Hash Table 和 LRU-K Replacement Policy是作为bufferpool的组件使用的</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/06/13/Buffer%20Pool%EF%BC%88cmu15445%20project1%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.dying.asia/2023/06/13/C++%20Primer%20(CMU15445%20project0%20)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="dying">
      <meta itemprop="description" content="想都是问题，做才是答案">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dying Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/13/C++%20Primer%20(CMU15445%20project0%20)/" class="post-title-link" itemprop="url">C++ Primer (CMU15445 project0 )</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-13 23:22:00 / 修改时间：22:08:34" itemprop="dateCreated datePublished" datetime="2023-06-13T23:22:00+08:00">2023-06-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cs-lab/" itemprop="url" rel="index"><span itemprop="name">cs-lab</span></a>
                </span>
            </span>

          
            <span id="/2023/06/13/C++%20Primer%20(CMU15445%20project0%20)/" class="post-meta-item leancloud_visitors" data-flag-title="C++ Primer (CMU15445 project0 )" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/06/13/C++%20Primer%20(CMU15445%20project0%20)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/06/13/C++%20Primer%20(CMU15445%20project0%20)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-Primer-CMU15445-project0"><a href="#C-Primer-CMU15445-project0" class="headerlink" title="C++ Primer (CMU15445 project0 )"></a>C++ Primer (CMU15445 project0 )</h1><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>课程网站：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2022/">CMU 15-445/645 :: Intro to Database Systems (Fall 2022)</a></p>
<p>github：<a target="_blank" rel="noopener" href="https://github.com/cmu-db/bustub">cmu-db/bustub:</a></p>
<p>cmu15445 是基于c++17 要求实现一个DBMS并且最后可以运行sql查询，再课程中Andy 也说这是可以用来在简历上写的项目，并且也可以拿到很不错的offer（但是国内写的人很多，就当一个练手的项目了，毕竟是要把基础四大件要写一遍的）</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/06/13/C++%20Primer%20(CMU15445%20project0%20)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dying"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">dying</p>
  <div class="site-description" itemprop="description">想都是问题，做才是答案</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/QYZing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;QYZing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2062656460@qq.com" title="E-Mail → mailto:2062656460@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蒙ICP备2023000237号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dying</span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'wFD2TJDXerlwQLJQOksbriCK-gzGzoHsz',
      appKey     : 'ErOISFE8uucXKBtDq5EVrhh4',
      placeholder: "输入你的评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '3' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
